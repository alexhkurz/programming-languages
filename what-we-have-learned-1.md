## What we have learned in Part 1

We have learned 

- the basics about parsing and precedence of operations. We can write a simple context-free grammar and use a "compiler compiler" to generate a parser from it.

- how abstract syntax is used as an intermediate representation to write an interpreter. Next semester, we will see how to use the same basic technique to implement a type checker and code generator for a fragment of C++.

- how to represent natural numbers using zero and successor and how to implement arithmetic by recursion on this representation.

- how equational reasoning and, more specifically, rewriting equations, is the model of computation not only underlying high-school arithmetic, but also functional programming. We will see that this extends to all of programming later.

## Further exercises

If you want to make sure that you master these concepts, an excellent way to do this is to add more features to the calculator, for example:

- conditionals (if-then-else)
- Booleans
- variables
- ...

## Coming up next ...

In the next part we will try to understand better how computation can mean anything if computation just consists of following the rules. Is there a way to make mathematically precise the "meaning of meaning", the relationship between syntax and semantics?