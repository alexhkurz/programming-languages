
## What we have learned in Part 3

We have learned 

- to distinguish free and bound variables.

- the syntax and operational semantics of lambda-calculus.

- that lambda-calculus is Turing complete, with its power stemming from higher-order functions.

- that lambda-calculus is a minimal (functional) programming language and how to extend it by adding various features such as conditionals, recursion, lists.

- that an interpreter of lambda-calculus can be implemented by a simple rewriting-of-equations approach and why this implementation is concise (50 loc on abstract syntax) but not efficient.

## Further exercises

If you want to check whether you understand these concepts, a good project would be to rewrite our interpreter of lambda-calculus so that it handles conditionals, numbers and lists in such a way that the beta-rule is the only computation rule.

## Coming up next ...


